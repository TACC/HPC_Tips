##----
Run "dos2unix" command to convert files from Windows/DOS format to Unix format when you transfer them to TACC resources. 
##----
Use the command "du -sh" to see total disk usage for the current directory.
##----
Use the command "du -h --max-depth=1" to see disk usage for all directories in the current directory.
##----
Use "!!" to repeat the most recent command. Use "!mpi" to repeat the most recent command that started with "mpi" and "!?mpi?" for the most recent one that contained "mpi".
##----
Use the command "cat -e -t -v Makefile" to check whether you are using tabs in your Makefile.
##----
Add the following include statements in your Makefile to compile PETSc code:
  include ${PETSC_DIR}/conf/variables
  include ${PETSC_DIR}/conf/rules
##----
Windows user looking for a robust approach to accessing Linux resources? Try running a Linux virtual machine inside a host app (hypervisor) like VirtualBox or VMWare player running on your desktop.
##----
Want to mount your supercomputer directories on your desktop? Try the sshfs utility.
##----
Load your favorite modules then execute "module save". Your saved collection will now be available on your next login, or anytime you execute "module restore".
##----
Bash does not automatically source your .bashrc on login; if you want this behavior, source your .bashrc from .profile or the login startup script of your choice.
##----
If "ls" takes a long time, try /bin/ls for a lean, mean, uncolorized version of ls.
##----
Before executing "rm", try "ls" with the same arguments and see if you like what you get.
##----
As long as your job is running, you can ssh to any node you own to monitor your job's progress. Try executing "top" then "1" for particularly useful display.
##----
Avoid recursive ("-r") file transfers; collect the files into a tar archive instead.
##----
Execute "module show xxxx" to see exactly what module xxxx does to your environment.
##----
To build software in your own user space, ./configure --prefix=$WORK/myapps is often the trick you're looking for.
##----
Execute "du -sch *" to see your disk usage by directory.
##----
An alias to display your $PATH with each directory on its own line:
   $ alias prettypath="echo \\$PATH | sed 's/:/\\n/g'"
##----
Want a robust approach to backup, transfer, and version control? Give git or mercurial a try; you'll be glad you did.
##----
Tired of all that typing? Did you know you can type "ml" instead of "module list" and  "ml git" instead of "module load git"?
##----
You can find all installed bio codes by executing
       $ module keyword bio
##----
To find out more about a particular module execute "module help <name>"
##----
Type "module help" to learn more about the Lmod module system.
##----
Did you know that you can only have one version a module loaded at a time?

    $ module load foo/1.2; module load foo/1.4  # only foo/1.4 will be loaded.
##----
The module command:

    $ ml -foo -bar baz qux

is the same as:

    $ module rm foo bar; module load baz qux
##----
The "settarg" module stores key environment information in the variable TARG that dynamically changes as modules are changed.  See "module help settarg" for more info.
##----
Type "module spider XXXXX" to find all the versions of module XXXXX.
##----
Chapters 2 thru 5 to the Gnu Make Manual provide a great introduction for any one wishing to understand this powerful tool. See "info make".
##----
If you want to see just the available default modules execute:

   $ module -d avail
##----
If you want to see all the currently loadable modules that contain the string "abc" execute:

   $ module avail abc

This works for spider and list as well.
##----
You can do simple regular expression searches:

   $ module -r spider '^p'

This will list all the modules that start with the letter p.
##----
You can save more than one collection of modules; just give each collection a name:

   $ module save projectA

You can load this collection by executing:

   $ module restore projectA
##----
Execute "module spider" to get a complete list of all installed software on the system.
##----
To get instant hyperlinks, compile your LaTeX files with "pdflatex" and put the following line in your source:

  \\usepackage[pdftex,colorlinks]{hyperref}
##----
You can switch back to the last directory by executing:
    $ cd -
##----
Tired of typing that long directory name? Use tab-completion instead:
    $ cd long<TAB>          becomes:
    $ cd longDirectoryName
##----
You can switch back to your home directory in the following three ways:
    $ cd $HOME
    $ cd ~
    $ cd
##----
No need to retype previous commands; use Ctrl+R to search for them.
##----
Here are four different ways to repeat the last executed command (press enter after each):
  * Use the up arrow
  * Type !!
  * Type !-1
  * Press Ctrl+P
##----
Here's a trick to execute the last three commands repeatedly.  Press the up-arrow key three times, then type Ctrl-O (the letter not the number).  This will execute the displayed command and bring up the next one in list. Repeat as desired.
##----
Try "history | more" to browse your recent commands together with their command numbers. To repeat a command, type !n (where "n" is the displayed command number).
##----
You can use "tail -F file_name" to follow the output to a file.
##----
You can create a hierarchy of directories at one time with "mkdir -p a/b/c".
##----
You can create a multiple directories at one time with "mkdir -p a/{b,c}/{d,e}".
This is the same as "mkdir -p a/b/d a/b/e a/c/d a/c/e".
##----
You can sort the output of "ls" in various ways. The command "ls -ltr" will sort so that the most recently changed files appear first.
##----
You can list a directory sorted by file size using "ls -lShr". The "-h" option reports sizes in human-readable form (bytes, KiloBytes, MegaBytes, etc.).
##----
Normally, "ls" does not show files that begin with a "." (so-called "hidden files"). You can list these files with "ls -a".
##----
The command "ls -F" adds an extra character to mark file type: '/' for directories '*' executables and '@' for symbolic links.
##----
Creating shell aliases is often easier than remembering/typing your favorite options:
  * ll  => ls -al
  * lf  => ls -aFC
  * lt  => ls -alhtr
##----
Keeping all sources up-to-date in all locations can be difficult.  Using "git" or similar version control software can make this simple.  Simply check-in and push locally, then pull remotely.  You'll wonder how you lived without it!
##----
"DRY" is an acronym for "Don't repeat yourself"  Avoid when you can, having repeating the same steps or code in multiple places, if only to protect yourself from having to find all the places when you need to make a change six months from now (cheerfully stolen from "The Pragmatic Programmer").
##----
Bash and Zsh support string manipulation tools:  HOST="sam.domain.com"; SHOST=${HOST%%.*} => sam. Google "bash string manipulation" for more details.
##----
Did you know that emacs and vim support spell checking?
##----
Did you know that both emacs and vim support color syntax highlighting?
##----
Emacs support etags (a code database.)  M-. will jump to a function definition, M-x tags-query-replace can change strings throughout a code tree.
##----
Vim support ctags (a code database.)  ctags -R *; Ctrl-] will jump to a function definition underneath the cursor.
##----
In vi, typing "." will repeat the last edit.
##----
With the mv and cp commands, you can copy or move a group of files into a directory:  "mv file.A file.B  file.C dir"  or "cp sam.* dir"
##----
When you need to match all ".*" files except for the current directory "." or the parent directory "..", use the ".??*" file globbing pattern.  For example:  "cp .??* dot.orig" copies all the dot files in a directory named "dot.orig".
##----
To list all hidden files without matching the current or parent directory, you can execute "ls .[^.]*".  This will match .a where as ".??*" will not. 
##----
Have you every tried to find the man-page for a function that has the same name as the command?  Try "man 2 <name>" or "man 3 <name>" for example "man 2 time". 
##----
The man-pages are divided into sections: section (1) are commands; section (2) are system functions, section (3) are library functions. (e.g. man 2 time; man 3 strlen)
##----
Try "man -k <key word>" to find the command or function you are looking for.
##----
Linux like all Unix O.S. allow commands to be "piped" together where the output of one is the input next.  So  "ls | grep key | more" will print a page at a time all files that match "key".
##----
Commands like ls, mv and cp support file globbing pattern matching:
  $  ls t*      #  -> list all files that start with t
  $  ls [tx]*   #  -> list all files that do start with t or x
  $  ls [^tx]*  #  -> list all files that do NOT start with t or x
  $  ls t?.sh   #  -> list files like t1.sh t2.sh but not t22.sh
##----
Did you know that you can edit the command line with emacs or vi commands?  By default, bash uses emacs style editing.  Use "set -o vi" to switch to vi style.  See https://www.gnu.org/software/bash/manual/html_node/Command-Line-Editing.html for more details.
##----
Need to view a graphics file (jpg and such)? Use the "display" command.
##----
Need override the definition of C compiler in a Makefile, just do:  "make CC=mpicc"
##----
Having trouble figuring out how a macro is being expanded?  Try pasting the line into a terminal and adding a "-E". For example try changing "mpicc -DFOO -DBAR -c foo.c" into "mpicc -DFOO -DBAR -E foo.c > foo.i" and look at the "foo.i" file.
##----
Your build process is failing and you know that you need an extra include directories.  Try setting CPATH to be colon separated list of directories.  Both the intel and gcc compilers will use the list as include paths (i.e. -I/foo/bar)
##----
Your build process is failing and you know that you need an extra library directories.  Try setting LIBRARY_PATH to be colon separated list of directories.  Both the intel and gcc compilers will use the list as library directories (-L/foo/bar).
##----
You can set CDPATH to be a list of parent directories that contain sub-directories to which you like to cd regularly.  For example if you set "CDPATH=.:~/a:~/b", then you can switch from ~/a/foo to ~/b/bar with "cd bar", then back with "cd foo".  Just define CDPATH (for example in your ~/.bashrc); do not export it.
##----
Want to measure how long a command takes, do:
   $ time a.out
##----
Want to know if two files are exactly the same use "cmp".  It is faster than diff.
##----
Aliases can be very helpful.  For example, these command in your ~/.bashrc will allows you to go backward inside your directory more quickly.
  alias cd2="cd ../.."
  alias cd3="cd ../../.."
##----
Want to mkdir and cd with a single command? You can use the following function in bash or zsh:
  function mkdircd () { mkdir -p "$1" && eval cd "$1"; } 
##----
You are writing too fast and misspelled the path of your directory while working in interactive bash session?
Try the following command "shopt -s cdspell" and bash  will try several minor spelling correction to see if it can find the actual directotory.
##----
Want to know the date or time from your terminal? Use the command "date"
##----
Want to know more about a bash command ? try to use the "--help" command. For example with mkdir:
  $ mkdir --help
##----
Want to know detailed information about a file do: "stat your_file_or_dir" to find out the create, access and modify times, permission etc.
##----
Want to compare 2 files? You can use diff.
  $ diff [options] file1 file2

Note: You can use the option -w in the diff command to ignore the white space while  performing the comparison. 
##----
Want to display the current time in the prompt? You can use the following command: export PS1="\\u@\\h [\\$(date +%k:%m:%S)]$ "
   doe@login1 [14:04:43]$ 
##----
There are several visual diff tools: meld, kdiff3, fldiff.  meld and kdiff3 are pretty.   fldiff will handle a files with huge number of diffs quickly.
##----
Emacs offers the "ediff mode" to quickly merge files.
##----
Vimdiff is a vi based tool to merge files.
##----
Did you know that bash sources your ~/.profile or ~/.bash_profile for login shells but sources ~/.bashrc on interactive shells?
##----
Did you know that C-shell sources your ~/.cshrc on EVERY kind of shell: login, interactive, non-interactive shells.
##----
Did you know that bash sources the file pointed to by the environment variable BASH_ENV when running a bash shell script but not a sh shell script?
##----
Since bash sources ~/.bashrc on every sub-shell you want to prevent things like path duplication by putting in guard if statements:
   if [ -z "$__INIT" ]; then
      export __INIT=1
      export PATH=$HOME/bin:$PATH
   fi
##----
In bash, the ~/.bash_profile or ~/.profile file is sourced on login shells and ~/.bashrc is sourced on non-login interactive shells.  You may wish to source your ~/.bashrc inside your ~/.bash_profile or ~/.profile startup script so that you get the same behavior on both kinds of interactive shells.
##----
Many times you'll want the last word on the previous command: "mkdir abc; cd abc".  Instead of retyping the last word over, you can use Meta-period  (M-.).  This keystroke will cycle through the last word on previous commands.  Note that on many keyboard Meta is the "Alt" key and on a Mac it may be the "command" key.
##----
Bash scripts can to simple arithmetic:  i=1; j=2; ((k=j*10+i)); echo $k -> 21
##----
A common error in a bash script is to put spaces around "=".  Right: A=10, Wrong: A = 10
##----
In a bash script, you can capture the output of a command with either:
   WD=`pwd`
   WD=$(pwd)
##----
Many unix command will report their version with "--version":
   $ ls --version
   ls (GNU coreutils) 8.4
##----
The gnu compilers and intel compilers support "-dumpversion" option to just report the version.
##----
The module command support "-t" or "--terse" for easy parsing.
##----
The module command support "-q" or "--quiet" option for silencing warnings.
##----
The terminal text can be cleared by typing "Ctrl+L".  It is the same as the command "clear".
##----
To prevent a command from being saved in your command history, put a space before the comand:
   $ <space>command
##----
To bypass any alias or shell function for "foo" do "\\foo".
##----
To delete the previous word use "Ctrl+W"
##----
To end an ssh connection do: "<enter>~."
##----
To print a file with line numbers do:
  $ nl <file>
##----
A complex if then else block in a shell script can be written  on one line as:
   $ [[ test ]] && if_true_do_this || otherwise_to_that
##----
To find broken symlinks do:
   $ find . -type l -xtype l
##----
To swap the two characters on the command line do: Ctrl+T
##----
To diff two variables do: "diff <(echo $a) <(echo $b)"
##----
The web site www.commandlinefu.com has command line gems.  Click on "All-Time greats" for the most popular tips.
##----
To know all the versions of a command do:
   $ type -a foo
##----
To print a random number between 1 and X do:
   $ echo $[RANDOM%X+1]
##----
Use Ctrl+U to clear the current line.
##----
To run a command in a different directory and jump back to the current directory, use parentheses create a sub-shell:
   $ (cd ~/project; make)
##----
When running a for loop in multiple directories, it may be helpful to use parentheses create a sub-shell:
   $ for d in d1 d2 d3 ; do  ( cd $d; do_some_command_here; ); done
##----
To reset a borked terminal try either:
   $ reset 
or
   $ Ctrl+J stty sane Ctrl+J
##----
